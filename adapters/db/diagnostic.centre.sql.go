// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: diagnostic.centre.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const create_Diagnostic_Centre = `-- name: Create_Diagnostic_Centre :one
INSERT INTO diagnostic_centres (
  diagnostic_centre_name,
  latitude,
  longitude,
  address,
  contact,
  doctors,
  available_tests,
  created_by,
  admin_id
) VALUES  (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at
`

type Create_Diagnostic_CentreParams struct {
	DiagnosticCentreName string        `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8 `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8 `db:"longitude" json:"longitude"`
	Address              []byte        `db:"address" json:"address"`
	Contact              []byte        `db:"contact" json:"contact"`
	Doctors              []string      `db:"doctors" json:"doctors"`
	AvailableTests       []string      `db:"available_tests" json:"available_tests"`
	CreatedBy            string        `db:"created_by" json:"created_by"`
	AdminID              string        `db:"admin_id" json:"admin_id"`
}

// Inserts a new diagnostic record into the diagnostic_centres table.
func (q *Queries) Create_Diagnostic_Centre(ctx context.Context, arg Create_Diagnostic_CentreParams) (*DiagnosticCentre, error) {
	row := q.db.QueryRow(ctx, create_Diagnostic_Centre,
		arg.DiagnosticCentreName,
		arg.Latitude,
		arg.Longitude,
		arg.Address,
		arg.Contact,
		arg.Doctors,
		arg.AvailableTests,
		arg.CreatedBy,
		arg.AdminID,
	)
	var i DiagnosticCentre
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const delete_Diagnostic_Centre_ByOwner = `-- name: Delete_Diagnostic_Centre_ByOwner :one
DELETE FROM diagnostic_centres WHERE id = $1 AND created_by = $2 RETURNING id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at
`

type Delete_Diagnostic_Centre_ByOwnerParams struct {
	ID        string `db:"id" json:"id"`
	CreatedBy string `db:"created_by" json:"created_by"`
}

// Deletes a diagnosticCentre only by the created_by.
func (q *Queries) Delete_Diagnostic_Centre_ByOwner(ctx context.Context, arg Delete_Diagnostic_Centre_ByOwnerParams) (*DiagnosticCentre, error) {
	row := q.db.QueryRow(ctx, delete_Diagnostic_Centre_ByOwner, arg.ID, arg.CreatedBy)
	var i DiagnosticCentre
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const find_Nearest_Diagnostic_Centres_WhenRejected = `-- name: Find_Nearest_Diagnostic_Centres_WhenRejected :many
SELECT
  id,
  diagnostic_centre_name,
  latitude,
  longitude,
  address,
  contact,
  doctors,
  available_tests,
  created_at,
  updated_at,
  CAST(
    6371 * acos(
      cos(radians($1)) * cos(radians(latitude)) *
      cos(radians(longitude) - radians($2)) +
      sin(radians($1)) * sin(radians(latitude))
    ) AS DOUBLE PRECISION
  ) AS distance_km 
FROM diagnostic_centres
WHERE
  id != $3 -- Exclude the current diagnostic centre
  AND latitude IS NOT NULL
  AND longitude IS NOT NULL
  AND (doctors @> $4 OR $4 IS NULL) -- doctor type
  AND (available_tests @> $5 OR $5 IS NULL) -- test type
ORDER BY
  distance_km ASC
LIMIT 3
`

type Find_Nearest_Diagnostic_Centres_WhenRejectedParams struct {
	Radians        float64  `db:"radians" json:"radians"`
	Radians_2      float64  `db:"radians_2" json:"radians_2"`
	ID             string   `db:"id" json:"id"`
	Doctors        []string `db:"doctors" json:"doctors"`
	AvailableTests []string `db:"available_tests" json:"available_tests"`
}

type Find_Nearest_Diagnostic_Centres_WhenRejectedRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []string           `db:"doctors" json:"doctors"`
	AvailableTests       []string           `db:"available_tests" json:"available_tests"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DistanceKm           float64            `db:"distance_km" json:"distance_km"`
}

func (q *Queries) Find_Nearest_Diagnostic_Centres_WhenRejected(ctx context.Context, arg Find_Nearest_Diagnostic_Centres_WhenRejectedParams) ([]*Find_Nearest_Diagnostic_Centres_WhenRejectedRow, error) {
	rows, err := q.db.Query(ctx, find_Nearest_Diagnostic_Centres_WhenRejected,
		arg.Radians,
		arg.Radians_2,
		arg.ID,
		arg.Doctors,
		arg.AvailableTests,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Find_Nearest_Diagnostic_Centres_WhenRejectedRow
	for rows.Next() {
		var i Find_Nearest_Diagnostic_Centres_WhenRejectedRow
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get_Diagnostic_Centre = `-- name: Get_Diagnostic_Centre :one
SELECT id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at FROM diagnostic_centres WHERE id = $1
`

// Retrieves a single diagnostic record by its ID.
func (q *Queries) Get_Diagnostic_Centre(ctx context.Context, id string) (*DiagnosticCentre, error) {
	row := q.db.QueryRow(ctx, get_Diagnostic_Centre, id)
	var i DiagnosticCentre
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const get_Diagnostic_Centre_ByManager = `-- name: Get_Diagnostic_Centre_ByManager :one
SELECT id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at FROM diagnostic_centres WHERE id = $1 AND admin_id = $2
`

type Get_Diagnostic_Centre_ByManagerParams struct {
	ID      string `db:"id" json:"id"`
	AdminID string `db:"admin_id" json:"admin_id"`
}

// GetDiagnosticCentreByManager
func (q *Queries) Get_Diagnostic_Centre_ByManager(ctx context.Context, arg Get_Diagnostic_Centre_ByManagerParams) (*DiagnosticCentre, error) {
	row := q.db.QueryRow(ctx, get_Diagnostic_Centre_ByManager, arg.ID, arg.AdminID)
	var i DiagnosticCentre
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const get_Diagnostic_Centre_ByOwner = `-- name: Get_Diagnostic_Centre_ByOwner :one
SELECT id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at FROM diagnostic_centres WHERE id = $1 AND created_by = $2
`

type Get_Diagnostic_Centre_ByOwnerParams struct {
	ID        string `db:"id" json:"id"`
	CreatedBy string `db:"created_by" json:"created_by"`
}

// GetADiagnosticCentreByOwner :one
func (q *Queries) Get_Diagnostic_Centre_ByOwner(ctx context.Context, arg Get_Diagnostic_Centre_ByOwnerParams) (*DiagnosticCentre, error) {
	row := q.db.QueryRow(ctx, get_Diagnostic_Centre_ByOwner, arg.ID, arg.CreatedBy)
	var i DiagnosticCentre
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const get_Nearest_Diagnostic_Centres = `-- name: Get_Nearest_Diagnostic_Centres :many
SELECT
  id,
  diagnostic_centre_name,
  latitude,
  longitude,
  address,
  contact,
  doctors,
  available_tests,
  created_at,
  updated_at,
  CAST(
    6371 * acos(
      cos(radians($1)) * cos(radians(latitude)) *
      cos(radians(longitude) - radians($2)) +
      sin(radians($1)) * sin(radians(latitude))
    ) AS DOUBLE PRECISION
  ) AS distance_km
FROM
  diagnostic_centres
WHERE
  latitude IS NOT NULL
  AND longitude IS NOT NULL
  AND (doctors @> $3 OR $3 IS NULL)
  AND (available_tests @> $4 OR $4 IS NULL)
ORDER BY
  distance_km ASC
LIMIT 50
`

type Get_Nearest_Diagnostic_CentresParams struct {
	Radians        float64  `db:"radians" json:"radians"`
	Radians_2      float64  `db:"radians_2" json:"radians_2"`
	Doctors        []string `db:"doctors" json:"doctors"`
	AvailableTests []string `db:"available_tests" json:"available_tests"`
}

type Get_Nearest_Diagnostic_CentresRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []string           `db:"doctors" json:"doctors"`
	AvailableTests       []string           `db:"available_tests" json:"available_tests"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DistanceKm           float64            `db:"distance_km" json:"distance_km"`
}

// Retrieves the nearest diagnostic centres based on latitude and longitude.
func (q *Queries) Get_Nearest_Diagnostic_Centres(ctx context.Context, arg Get_Nearest_Diagnostic_CentresParams) ([]*Get_Nearest_Diagnostic_CentresRow, error) {
	rows, err := q.db.Query(ctx, get_Nearest_Diagnostic_Centres,
		arg.Radians,
		arg.Radians_2,
		arg.Doctors,
		arg.AvailableTests,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Get_Nearest_Diagnostic_CentresRow
	for rows.Next() {
		var i Get_Nearest_Diagnostic_CentresRow
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const list_Diagnostic_Centres_ByOwner = `-- name: List_Diagnostic_Centres_ByOwner :many
SELECT id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at FROM diagnostic_centres WHERE created_by = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type List_Diagnostic_Centres_ByOwnerParams struct {
	CreatedBy string `db:"created_by" json:"created_by"`
	Limit     int32  `db:"limit" json:"limit"`
	Offset    int32  `db:"offset" json:"offset"`
}

// Retrieves all diagnostic records for a specific owner.
func (q *Queries) List_Diagnostic_Centres_ByOwner(ctx context.Context, arg List_Diagnostic_Centres_ByOwnerParams) ([]*DiagnosticCentre, error) {
	rows, err := q.db.Query(ctx, list_Diagnostic_Centres_ByOwner, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticCentre
	for rows.Next() {
		var i DiagnosticCentre
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedBy,
			&i.AdminID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieve_Diagnostic_Centres = `-- name: Retrieve_Diagnostic_Centres :many
SELECT id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at FROM diagnostic_centres
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type Retrieve_Diagnostic_CentresParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

// Retrieves all diagnostic records with pagination.
func (q *Queries) Retrieve_Diagnostic_Centres(ctx context.Context, arg Retrieve_Diagnostic_CentresParams) ([]*DiagnosticCentre, error) {
	rows, err := q.db.Query(ctx, retrieve_Diagnostic_Centres, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticCentre
	for rows.Next() {
		var i DiagnosticCentre
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedBy,
			&i.AdminID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const search_Diagnostic_Centres = `-- name: Search_Diagnostic_Centres :many
SELECT id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at
FROM diagnostic_centres
WHERE
  (diagnostic_centre_name ILIKE '%' || $1 || '%' OR $1 IS NULL)
  AND (doctors @> $2 OR $2 IS NULL)
  AND (available_tests @> $3 OR $3 IS NULL)
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type Search_Diagnostic_CentresParams struct {
	Column1        pgtype.Text `db:"column_1" json:"column_1"`
	Doctors        []string    `db:"doctors" json:"doctors"`
	AvailableTests []string    `db:"available_tests" json:"available_tests"`
	Limit          int32       `db:"limit" json:"limit"`
	Offset         int32       `db:"offset" json:"offset"`
}

// Searches diagnostic_centres by name with pagination.
func (q *Queries) Search_Diagnostic_Centres(ctx context.Context, arg Search_Diagnostic_CentresParams) ([]*DiagnosticCentre, error) {
	rows, err := q.db.Query(ctx, search_Diagnostic_Centres,
		arg.Column1,
		arg.Doctors,
		arg.AvailableTests,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticCentre
	for rows.Next() {
		var i DiagnosticCentre
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedBy,
			&i.AdminID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const search_Diagnostic_Centres_ByDoctor = `-- name: Search_Diagnostic_Centres_ByDoctor :many
SELECT id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at
FROM diagnostic_centres
WHERE
  (diagnostic_centre_name ILIKE '%' || $1 || '%' OR $1 IS NULL)
  AND (doctors @> $2)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type Search_Diagnostic_Centres_ByDoctorParams struct {
	Column1 pgtype.Text `db:"column_1" json:"column_1"`
	Doctors []string    `db:"doctors" json:"doctors"`
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
}

// SearchDiagnosticWith Doctor type
func (q *Queries) Search_Diagnostic_Centres_ByDoctor(ctx context.Context, arg Search_Diagnostic_Centres_ByDoctorParams) ([]*DiagnosticCentre, error) {
	rows, err := q.db.Query(ctx, search_Diagnostic_Centres_ByDoctor,
		arg.Column1,
		arg.Doctors,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticCentre
	for rows.Next() {
		var i DiagnosticCentre
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedBy,
			&i.AdminID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update_Diagnostic_Centre_ByOwner = `-- name: Update_Diagnostic_Centre_ByOwner :one
UPDATE diagnostic_centres
SET
  diagnostic_centre_name = COALESCE($3, diagnostic_centre_name),
  latitude = COALESCE($4, latitude),
  longitude = COALESCE($5, longitude),
  address = COALESCE($6, address),
  contact = COALESCE($7, contact),
  doctors = COALESCE($8, doctors),
  available_tests = COALESCE($9, available_tests),
  admin_id = COALESCE($10, admin_id),
  updated_at = NOW()
WHERE id = $1 AND created_by = $2
RETURNING id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at
`

type Update_Diagnostic_Centre_ByOwnerParams struct {
	ID                   string        `db:"id" json:"id"`
	CreatedBy            string        `db:"created_by" json:"created_by"`
	DiagnosticCentreName string        `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8 `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8 `db:"longitude" json:"longitude"`
	Address              []byte        `db:"address" json:"address"`
	Contact              []byte        `db:"contact" json:"contact"`
	Doctors              []string      `db:"doctors" json:"doctors"`
	AvailableTests       []string      `db:"available_tests" json:"available_tests"`
	AdminID              string        `db:"admin_id" json:"admin_id"`
}

// Updates a diagnostic centre by the owner.
func (q *Queries) Update_Diagnostic_Centre_ByOwner(ctx context.Context, arg Update_Diagnostic_Centre_ByOwnerParams) (*DiagnosticCentre, error) {
	row := q.db.QueryRow(ctx, update_Diagnostic_Centre_ByOwner,
		arg.ID,
		arg.CreatedBy,
		arg.DiagnosticCentreName,
		arg.Latitude,
		arg.Longitude,
		arg.Address,
		arg.Contact,
		arg.Doctors,
		arg.AvailableTests,
		arg.AdminID,
	)
	var i DiagnosticCentre
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
