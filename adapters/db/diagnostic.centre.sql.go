// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: diagnostic.centre.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const create_Diagnostic_Centre = `-- name: Create_Diagnostic_Centre :one
INSERT INTO diagnostic_centres (
  diagnostic_centre_name,
  latitude,
  longitude,
  address,
  contact,
  doctors,
  available_tests,
  created_by,
  admin_id
) VALUES  (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at
`

type Create_Diagnostic_CentreParams struct {
	DiagnosticCentreName string           `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8    `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8    `db:"longitude" json:"longitude"`
	Address              []byte           `db:"address" json:"address"`
	Contact              []byte           `db:"contact" json:"contact"`
	Doctors              []Doctor         `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests `db:"available_tests" json:"available_tests"`
	CreatedBy            string           `db:"created_by" json:"created_by"`
	AdminID              string           `db:"admin_id" json:"admin_id"`
}

// Inserts a new diagnostic record into the diagnostic_centres table.
func (q *Queries) Create_Diagnostic_Centre(ctx context.Context, arg Create_Diagnostic_CentreParams) (*DiagnosticCentre, error) {
	row := q.db.QueryRow(ctx, create_Diagnostic_Centre,
		arg.DiagnosticCentreName,
		arg.Latitude,
		arg.Longitude,
		arg.Address,
		arg.Contact,
		arg.Doctors,
		arg.AvailableTests,
		arg.CreatedBy,
		arg.AdminID,
	)
	var i DiagnosticCentre
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const delete_Diagnostic_Centre_ByOwner = `-- name: Delete_Diagnostic_Centre_ByOwner :one
DELETE FROM diagnostic_centres WHERE id = $1 AND created_by = $2 RETURNING id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at
`

type Delete_Diagnostic_Centre_ByOwnerParams struct {
	ID        string `db:"id" json:"id"`
	CreatedBy string `db:"created_by" json:"created_by"`
}

// Deletes a diagnosticCentre only by the created_by.
func (q *Queries) Delete_Diagnostic_Centre_ByOwner(ctx context.Context, arg Delete_Diagnostic_Centre_ByOwnerParams) (*DiagnosticCentre, error) {
	row := q.db.QueryRow(ctx, delete_Diagnostic_Centre_ByOwner, arg.ID, arg.CreatedBy)
	var i DiagnosticCentre
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const find_Nearest_Diagnostic_Centres_WhenRejected = `-- name: Find_Nearest_Diagnostic_Centres_WhenRejected :many
SELECT
  dc.id,
  dc.diagnostic_centre_name,
  dc.latitude,
  dc.longitude,
  dc.address,
  dc.contact,
  dc.doctors,
  dc.available_tests,
  dc.created_at,
  dc.updated_at,
  ARRAY_AGG(
    json_build_object(
      'day_of_week', dca.day_of_week,
      'start_time', dca.start_time,
      'end_time', dca.end_time,
      'max_appointments', dca.max_appointments,
      'slot_duration', dca.slot_duration,
      'break_time', dca.break_time
    )
  ) FILTER (WHERE dca.diagnostic_centre_id IS NOT NULL) as availability,
  CAST(
    6371 * acos(
      cos(radians($1)) * cos(radians(dc.latitude)) *
      cos(radians(dc.longitude) - radians($2)) +
      sin(radians($1)) * sin(radians(dc.latitude))
    ) AS DOUBLE PRECISION
  ) AS distance_km 
FROM diagnostic_centres dc
LEFT JOIN diagnostic_centre_availability dca ON dc.id = dca.diagnostic_centre_id
WHERE
  dc.id != $3 -- Exclude the current diagnostic centre
  AND dc.latitude IS NOT NULL
  AND dc.longitude IS NOT NULL
  AND (dc.doctors @> $4 OR $4 IS NULL) -- doctor type
  AND (dc.available_tests @> $5 OR $5 IS NULL) -- test type
GROUP BY
  dc.id
ORDER BY
  distance_km ASC
LIMIT 3
`

type Find_Nearest_Diagnostic_Centres_WhenRejectedParams struct {
	Radians        float64          `db:"radians" json:"radians"`
	Radians_2      float64          `db:"radians_2" json:"radians_2"`
	ID             string           `db:"id" json:"id"`
	Doctors        []Doctor         `db:"doctors" json:"doctors"`
	AvailableTests []AvailableTests `db:"available_tests" json:"available_tests"`
}

type Find_Nearest_Diagnostic_Centres_WhenRejectedRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []Doctor           `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests   `db:"available_tests" json:"available_tests"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Availability         interface{}        `db:"availability" json:"availability"`
	DistanceKm           float64            `db:"distance_km" json:"distance_km"`
}

func (q *Queries) Find_Nearest_Diagnostic_Centres_WhenRejected(ctx context.Context, arg Find_Nearest_Diagnostic_Centres_WhenRejectedParams) ([]*Find_Nearest_Diagnostic_Centres_WhenRejectedRow, error) {
	rows, err := q.db.Query(ctx, find_Nearest_Diagnostic_Centres_WhenRejected,
		arg.Radians,
		arg.Radians_2,
		arg.ID,
		arg.Doctors,
		arg.AvailableTests,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Find_Nearest_Diagnostic_Centres_WhenRejectedRow
	for rows.Next() {
		var i Find_Nearest_Diagnostic_Centres_WhenRejectedRow
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Availability,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get_Diagnostic_Centre = `-- name: Get_Diagnostic_Centre :one
SELECT 
  dc.id, dc.diagnostic_centre_name, dc.latitude, dc.longitude, dc.address, dc.contact, dc.doctors, dc.available_tests, dc.created_by, dc.admin_id, dc.created_at, dc.updated_at,
  ARRAY_AGG(
    json_build_object(
      'day_of_week', dca.day_of_week,
      'start_time', dca.start_time,
      'end_time', dca.end_time,
      'max_appointments', dca.max_appointments,
      'slot_duration', dca.slot_duration,
      'break_time', dca.break_time
    )
  ) FILTER (WHERE dca.diagnostic_centre_id IS NOT NULL) as availability
FROM diagnostic_centres dc
LEFT JOIN diagnostic_centre_availability dca ON dc.id = dca.diagnostic_centre_id
WHERE dc.id = $1
GROUP BY dc.id
`

type Get_Diagnostic_CentreRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []Doctor           `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests   `db:"available_tests" json:"available_tests"`
	CreatedBy            string             `db:"created_by" json:"created_by"`
	AdminID              string             `db:"admin_id" json:"admin_id"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Availability         interface{}        `db:"availability" json:"availability"`
}

// Retrieves a single diagnostic record by its ID.
func (q *Queries) Get_Diagnostic_Centre(ctx context.Context, id string) (*Get_Diagnostic_CentreRow, error) {
	row := q.db.QueryRow(ctx, get_Diagnostic_Centre, id)
	var i Get_Diagnostic_CentreRow
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Availability,
	)
	return &i, err
}

const get_Diagnostic_Centre_ByManager = `-- name: Get_Diagnostic_Centre_ByManager :one
SELECT 
  dc.id, dc.diagnostic_centre_name, dc.latitude, dc.longitude, dc.address, dc.contact, dc.doctors, dc.available_tests, dc.created_by, dc.admin_id, dc.created_at, dc.updated_at,
  ARRAY_AGG(
    json_build_object(
      'day_of_week', dca.day_of_week,
      'start_time', dca.start_time,
      'end_time', dca.end_time,
      'max_appointments', dca.max_appointments,
      'slot_duration', dca.slot_duration,
      'break_time', dca.break_time
    )
  ) FILTER (WHERE dca.diagnostic_centre_id IS NOT NULL) as availability
FROM diagnostic_centres dc
LEFT JOIN diagnostic_centre_availability dca ON dc.id = dca.diagnostic_centre_id
WHERE dc.id = $1 AND dc.admin_id = $2
GROUP BY dc.id
`

type Get_Diagnostic_Centre_ByManagerParams struct {
	ID      string `db:"id" json:"id"`
	AdminID string `db:"admin_id" json:"admin_id"`
}

type Get_Diagnostic_Centre_ByManagerRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []Doctor           `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests   `db:"available_tests" json:"available_tests"`
	CreatedBy            string             `db:"created_by" json:"created_by"`
	AdminID              string             `db:"admin_id" json:"admin_id"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Availability         interface{}        `db:"availability" json:"availability"`
}

// GetDiagnosticCentreByManager
func (q *Queries) Get_Diagnostic_Centre_ByManager(ctx context.Context, arg Get_Diagnostic_Centre_ByManagerParams) (*Get_Diagnostic_Centre_ByManagerRow, error) {
	row := q.db.QueryRow(ctx, get_Diagnostic_Centre_ByManager, arg.ID, arg.AdminID)
	var i Get_Diagnostic_Centre_ByManagerRow
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Availability,
	)
	return &i, err
}

const get_Diagnostic_Centre_ByOwner = `-- name: Get_Diagnostic_Centre_ByOwner :one
SELECT 
  dc.id, dc.diagnostic_centre_name, dc.latitude, dc.longitude, dc.address, dc.contact, dc.doctors, dc.available_tests, dc.created_by, dc.admin_id, dc.created_at, dc.updated_at,
  ARRAY_AGG(
    json_build_object(
      'day_of_week', dca.day_of_week,
      'start_time', dca.start_time,
      'end_time', dca.end_time,
      'max_appointments', dca.max_appointments,
      'slot_duration', dca.slot_duration,
      'break_time', dca.break_time
    )
  ) FILTER (WHERE dca.diagnostic_centre_id IS NOT NULL) as availability
FROM diagnostic_centres dc
LEFT JOIN diagnostic_centre_availability dca ON dc.id = dca.diagnostic_centre_id
WHERE dc.id = $1 AND dc.created_by = $2
GROUP BY dc.id
`

type Get_Diagnostic_Centre_ByOwnerParams struct {
	ID        string `db:"id" json:"id"`
	CreatedBy string `db:"created_by" json:"created_by"`
}

type Get_Diagnostic_Centre_ByOwnerRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []Doctor           `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests   `db:"available_tests" json:"available_tests"`
	CreatedBy            string             `db:"created_by" json:"created_by"`
	AdminID              string             `db:"admin_id" json:"admin_id"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Availability         interface{}        `db:"availability" json:"availability"`
}

// GetADiagnosticCentreByOwner :one
func (q *Queries) Get_Diagnostic_Centre_ByOwner(ctx context.Context, arg Get_Diagnostic_Centre_ByOwnerParams) (*Get_Diagnostic_Centre_ByOwnerRow, error) {
	row := q.db.QueryRow(ctx, get_Diagnostic_Centre_ByOwner, arg.ID, arg.CreatedBy)
	var i Get_Diagnostic_Centre_ByOwnerRow
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Availability,
	)
	return &i, err
}

const get_Nearest_Diagnostic_Centres = `-- name: Get_Nearest_Diagnostic_Centres :many
WITH filtered_centres AS (
  SELECT DISTINCT dc.id
  FROM diagnostic_centres dc
  WHERE
    dc.latitude IS NOT NULL
    AND dc.longitude IS NOT NULL
    AND (dc.doctors @> $3 OR $3 IS NULL)
    AND (dc.available_tests @> $4 OR $4 IS NULL)
    AND ($5 = '' OR EXISTS (
      SELECT 1
      FROM diagnostic_centre_availability dca2 
      WHERE dca2.diagnostic_centre_id = dc.id
      AND dca2.day_of_week = $5
    ))
)
SELECT
  dc.id,
  dc.diagnostic_centre_name,
  dc.latitude,
  dc.longitude,
  dc.address,
  dc.contact,
  dc.doctors,
  dc.available_tests,
  dc.created_at,
  dc.updated_at,
  ARRAY_AGG(
    DISTINCT jsonb_build_object(
      'day_of_week', dca.day_of_week,
      'start_time', dca.start_time,
      'end_time', dca.end_time,
      'max_appointments', dca.max_appointments,
      'slot_duration', dca.slot_duration,
      'break_time', dca.break_time
    )
  ) FILTER (
    WHERE dca.diagnostic_centre_id IS NOT NULL 
    AND ($5 = '' OR dca.day_of_week = $5)
  ) as availability,
  CAST(
    6371 * acos(
      cos(radians($1)) * cos(radians(dc.latitude)) *
      cos(radians(dc.longitude) - radians($2)) +
      sin(radians($1)) * sin(radians(dc.latitude))
    ) AS DOUBLE PRECISION
  ) AS distance_km
FROM filtered_centres fc
JOIN diagnostic_centres dc ON dc.id = fc.id
LEFT JOIN diagnostic_centre_availability dca ON dc.id = dca.diagnostic_centre_id
GROUP BY
  dc.id, dc.diagnostic_centre_name, dc.latitude, dc.longitude, dc.address,
  dc.contact, dc.doctors, dc.available_tests, dc.created_at, dc.updated_at
ORDER BY
  distance_km ASC
LIMIT 50
`

type Get_Nearest_Diagnostic_CentresParams struct {
	Radians        float64          `db:"radians" json:"radians"`
	Radians_2      float64          `db:"radians_2" json:"radians_2"`
	Doctors        []Doctor         `db:"doctors" json:"doctors"`
	AvailableTests []AvailableTests `db:"available_tests" json:"available_tests"`
	Column5        interface{}      `db:"column_5" json:"column_5"`
}

type Get_Nearest_Diagnostic_CentresRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []Doctor           `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests   `db:"available_tests" json:"available_tests"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Availability         interface{}        `db:"availability" json:"availability"`
	DistanceKm           float64            `db:"distance_km" json:"distance_km"`
}

// Retrieves the nearest diagnostic centres based on latitude and longitude.
func (q *Queries) Get_Nearest_Diagnostic_Centres(ctx context.Context, arg Get_Nearest_Diagnostic_CentresParams) ([]*Get_Nearest_Diagnostic_CentresRow, error) {
	rows, err := q.db.Query(ctx, get_Nearest_Diagnostic_Centres,
		arg.Radians,
		arg.Radians_2,
		arg.Doctors,
		arg.AvailableTests,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Get_Nearest_Diagnostic_CentresRow
	for rows.Next() {
		var i Get_Nearest_Diagnostic_CentresRow
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Availability,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const list_Diagnostic_Centres_ByOwner = `-- name: List_Diagnostic_Centres_ByOwner :many
SELECT 
  dc.id, dc.diagnostic_centre_name, dc.latitude, dc.longitude, dc.address, dc.contact, dc.doctors, dc.available_tests, dc.created_by, dc.admin_id, dc.created_at, dc.updated_at,
  ARRAY_AGG(
    json_build_object(
      'day_of_week', dca.day_of_week,
      'start_time', dca.start_time,
      'end_time', dca.end_time,
      'max_appointments', dca.max_appointments,
      'slot_duration', dca.slot_duration,
      'break_time', dca.break_time
    )
  ) FILTER (WHERE dca.diagnostic_centre_id IS NOT NULL) as availability
FROM diagnostic_centres dc
LEFT JOIN diagnostic_centre_availability dca ON dc.id = dca.diagnostic_centre_id
WHERE dc.created_by = $1
GROUP BY dc.id
ORDER BY dc.created_at DESC
LIMIT $2 OFFSET $3
`

type List_Diagnostic_Centres_ByOwnerParams struct {
	CreatedBy string `db:"created_by" json:"created_by"`
	Limit     int32  `db:"limit" json:"limit"`
	Offset    int32  `db:"offset" json:"offset"`
}

type List_Diagnostic_Centres_ByOwnerRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []Doctor           `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests   `db:"available_tests" json:"available_tests"`
	CreatedBy            string             `db:"created_by" json:"created_by"`
	AdminID              string             `db:"admin_id" json:"admin_id"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Availability         interface{}        `db:"availability" json:"availability"`
}

// Retrieves all diagnostic records for a specific owner.
func (q *Queries) List_Diagnostic_Centres_ByOwner(ctx context.Context, arg List_Diagnostic_Centres_ByOwnerParams) ([]*List_Diagnostic_Centres_ByOwnerRow, error) {
	rows, err := q.db.Query(ctx, list_Diagnostic_Centres_ByOwner, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*List_Diagnostic_Centres_ByOwnerRow
	for rows.Next() {
		var i List_Diagnostic_Centres_ByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedBy,
			&i.AdminID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Availability,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieve_Diagnostic_Centres = `-- name: Retrieve_Diagnostic_Centres :many
SELECT 
  dc.id, dc.diagnostic_centre_name, dc.latitude, dc.longitude, dc.address, dc.contact, dc.doctors, dc.available_tests, dc.created_by, dc.admin_id, dc.created_at, dc.updated_at,
  ARRAY_AGG(
    json_build_object(
      'day_of_week', dca.day_of_week,
      'start_time', dca.start_time,
      'end_time', dca.end_time,
      'max_appointments', dca.max_appointments,
      'slot_duration', dca.slot_duration,
      'break_time', dca.break_time
    )
  ) FILTER (WHERE dca.diagnostic_centre_id IS NOT NULL) as availability
FROM diagnostic_centres dc
LEFT JOIN diagnostic_centre_availability dca ON dc.id = dca.diagnostic_centre_id
GROUP BY dc.id
ORDER BY dc.created_at DESC
LIMIT $1 OFFSET $2
`

type Retrieve_Diagnostic_CentresParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type Retrieve_Diagnostic_CentresRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []Doctor           `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests   `db:"available_tests" json:"available_tests"`
	CreatedBy            string             `db:"created_by" json:"created_by"`
	AdminID              string             `db:"admin_id" json:"admin_id"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Availability         interface{}        `db:"availability" json:"availability"`
}

// Retrieves all diagnostic records with pagination.
func (q *Queries) Retrieve_Diagnostic_Centres(ctx context.Context, arg Retrieve_Diagnostic_CentresParams) ([]*Retrieve_Diagnostic_CentresRow, error) {
	rows, err := q.db.Query(ctx, retrieve_Diagnostic_Centres, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Retrieve_Diagnostic_CentresRow
	for rows.Next() {
		var i Retrieve_Diagnostic_CentresRow
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedBy,
			&i.AdminID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Availability,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const search_Diagnostic_Centres = `-- name: Search_Diagnostic_Centres :many
SELECT 
  dc.id, dc.diagnostic_centre_name, dc.latitude, dc.longitude, dc.address, dc.contact, dc.doctors, dc.available_tests, dc.created_by, dc.admin_id, dc.created_at, dc.updated_at,
  ARRAY_AGG(
    json_build_object(
      'day_of_week', dca.day_of_week,
      'start_time', dca.start_time,
      'end_time', dca.end_time,
      'max_appointments', dca.max_appointments,
      'slot_duration', dca.slot_duration,
      'break_time', dca.break_time
    )
  ) as availability
FROM diagnostic_centres dc
LEFT JOIN diagnostic_centre_availability dca ON dc.id = dca.diagnostic_centre_id
WHERE
  (dc.diagnostic_centre_name ILIKE '%' || $1 || '%' OR $1 IS NULL)
  AND (dc.doctors @> $2 OR $2 IS NULL)
  AND (dc.available_tests @> $3 OR $3 IS NULL)
ORDER BY dc.created_at DESC
LIMIT $4 OFFSET $5
`

type Search_Diagnostic_CentresParams struct {
	Column1        pgtype.Text      `db:"column_1" json:"column_1"`
	Doctors        []Doctor         `db:"doctors" json:"doctors"`
	AvailableTests []AvailableTests `db:"available_tests" json:"available_tests"`
	Limit          int32            `db:"limit" json:"limit"`
	Offset         int32            `db:"offset" json:"offset"`
}

type Search_Diagnostic_CentresRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []Doctor           `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests   `db:"available_tests" json:"available_tests"`
	CreatedBy            string             `db:"created_by" json:"created_by"`
	AdminID              string             `db:"admin_id" json:"admin_id"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Availability         interface{}        `db:"availability" json:"availability"`
}

// Searches diagnostic_centres by name with pagination.
func (q *Queries) Search_Diagnostic_Centres(ctx context.Context, arg Search_Diagnostic_CentresParams) ([]*Search_Diagnostic_CentresRow, error) {
	rows, err := q.db.Query(ctx, search_Diagnostic_Centres,
		arg.Column1,
		arg.Doctors,
		arg.AvailableTests,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Search_Diagnostic_CentresRow
	for rows.Next() {
		var i Search_Diagnostic_CentresRow
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedBy,
			&i.AdminID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Availability,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const search_Diagnostic_Centres_ByDoctor = `-- name: Search_Diagnostic_Centres_ByDoctor :many
SELECT 
  dc.id, dc.diagnostic_centre_name, dc.latitude, dc.longitude, dc.address, dc.contact, dc.doctors, dc.available_tests, dc.created_by, dc.admin_id, dc.created_at, dc.updated_at,
  ARRAY_AGG(
    json_build_object(
      'day_of_week', dca.day_of_week,
      'start_time', dca.start_time,
      'end_time', dca.end_time,
      'max_appointments', dca.max_appointments,
      'slot_duration', dca.slot_duration,
      'break_time', dca.break_time
    )
  ) FILTER (WHERE dca.diagnostic_centre_id IS NOT NULL) as availability
FROM diagnostic_centres dc
LEFT JOIN diagnostic_centre_availability dca ON dc.id = dca.diagnostic_centre_id
WHERE
  (dc.diagnostic_centre_name ILIKE '%' || $1 || '%' OR $1 IS NULL)
  AND (dc.doctors @> $2)
GROUP BY dc.id
ORDER BY dc.created_at DESC
LIMIT $3 OFFSET $4
`

type Search_Diagnostic_Centres_ByDoctorParams struct {
	Column1 pgtype.Text `db:"column_1" json:"column_1"`
	Doctors []Doctor    `db:"doctors" json:"doctors"`
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
}

type Search_Diagnostic_Centres_ByDoctorRow struct {
	ID                   string             `db:"id" json:"id"`
	DiagnosticCentreName string             `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8      `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8      `db:"longitude" json:"longitude"`
	Address              []byte             `db:"address" json:"address"`
	Contact              []byte             `db:"contact" json:"contact"`
	Doctors              []Doctor           `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests   `db:"available_tests" json:"available_tests"`
	CreatedBy            string             `db:"created_by" json:"created_by"`
	AdminID              string             `db:"admin_id" json:"admin_id"`
	CreatedAt            pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	Availability         interface{}        `db:"availability" json:"availability"`
}

// SearchDiagnosticWith Doctor type
func (q *Queries) Search_Diagnostic_Centres_ByDoctor(ctx context.Context, arg Search_Diagnostic_Centres_ByDoctorParams) ([]*Search_Diagnostic_Centres_ByDoctorRow, error) {
	rows, err := q.db.Query(ctx, search_Diagnostic_Centres_ByDoctor,
		arg.Column1,
		arg.Doctors,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Search_Diagnostic_Centres_ByDoctorRow
	for rows.Next() {
		var i Search_Diagnostic_Centres_ByDoctorRow
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreName,
			&i.Latitude,
			&i.Longitude,
			&i.Address,
			&i.Contact,
			&i.Doctors,
			&i.AvailableTests,
			&i.CreatedBy,
			&i.AdminID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Availability,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update_Diagnostic_Centre_ByOwner = `-- name: Update_Diagnostic_Centre_ByOwner :one
UPDATE diagnostic_centres
SET
  diagnostic_centre_name = COALESCE($3, diagnostic_centre_name),
  latitude = COALESCE($4, latitude),
  longitude = COALESCE($5, longitude),
  address = COALESCE($6, address),
  contact = COALESCE($7, contact),
  doctors = COALESCE($8, doctors),
  available_tests = COALESCE($9, available_tests),
  admin_id = COALESCE($10, admin_id),
  updated_at = NOW()
WHERE id = $1 AND created_by = $2
RETURNING id, diagnostic_centre_name, latitude, longitude, address, contact, doctors, available_tests, created_by, admin_id, created_at, updated_at
`

type Update_Diagnostic_Centre_ByOwnerParams struct {
	ID                   string           `db:"id" json:"id"`
	CreatedBy            string           `db:"created_by" json:"created_by"`
	DiagnosticCentreName string           `db:"diagnostic_centre_name" json:"diagnostic_centre_name"`
	Latitude             pgtype.Float8    `db:"latitude" json:"latitude"`
	Longitude            pgtype.Float8    `db:"longitude" json:"longitude"`
	Address              []byte           `db:"address" json:"address"`
	Contact              []byte           `db:"contact" json:"contact"`
	Doctors              []Doctor         `db:"doctors" json:"doctors"`
	AvailableTests       []AvailableTests `db:"available_tests" json:"available_tests"`
	AdminID              string           `db:"admin_id" json:"admin_id"`
}

// Updates a diagnostic centre by the owner.
func (q *Queries) Update_Diagnostic_Centre_ByOwner(ctx context.Context, arg Update_Diagnostic_Centre_ByOwnerParams) (*DiagnosticCentre, error) {
	row := q.db.QueryRow(ctx, update_Diagnostic_Centre_ByOwner,
		arg.ID,
		arg.CreatedBy,
		arg.DiagnosticCentreName,
		arg.Latitude,
		arg.Longitude,
		arg.Address,
		arg.Contact,
		arg.Doctors,
		arg.AvailableTests,
		arg.AdminID,
	)
	var i DiagnosticCentre
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreName,
		&i.Latitude,
		&i.Longitude,
		&i.Address,
		&i.Contact,
		&i.Doctors,
		&i.AvailableTests,
		&i.CreatedBy,
		&i.AdminID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
