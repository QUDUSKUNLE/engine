// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: appointment.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelAppointment = `-- name: CancelAppointment :one
UPDATE appointments 
SET 
    status = 'cancelled',
    cancellation_reason = $2,
    cancelled_by = $3,
    cancellation_time = CURRENT_TIMESTAMP,
    cancellation_fee = COALESCE($4, 0),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, patient_id, schedule_id, diagnostic_centre_id, appointment_date, time_slot, status, payment_id, payment_status, payment_amount, payment_date, check_in_time, completion_time, notes, cancellation_reason, cancelled_by, cancellation_time, cancellation_fee, original_appointment_id, rescheduling_reason, rescheduled_by, rescheduling_time, rescheduling_fee, created_at, updated_at, reminder_sent, reminder_sent_at
`

type CancelAppointmentParams struct {
	ID                 string         `db:"id" json:"id"`
	CancellationReason pgtype.Text    `db:"cancellation_reason" json:"cancellation_reason"`
	CancelledBy        pgtype.UUID    `db:"cancelled_by" json:"cancelled_by"`
	CancellationFee    pgtype.Numeric `db:"cancellation_fee" json:"cancellation_fee"`
}

func (q *Queries) CancelAppointment(ctx context.Context, arg CancelAppointmentParams) (*Appointment, error) {
	row := q.db.QueryRow(ctx, cancelAppointment,
		arg.ID,
		arg.CancellationReason,
		arg.CancelledBy,
		arg.CancellationFee,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.ScheduleID,
		&i.DiagnosticCentreID,
		&i.AppointmentDate,
		&i.TimeSlot,
		&i.Status,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.PaymentAmount,
		&i.PaymentDate,
		&i.CheckInTime,
		&i.CompletionTime,
		&i.Notes,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.CancellationTime,
		&i.CancellationFee,
		&i.OriginalAppointmentID,
		&i.ReschedulingReason,
		&i.RescheduledBy,
		&i.ReschedulingTime,
		&i.ReschedulingFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderSent,
		&i.ReminderSentAt,
	)
	return &i, err
}

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO appointments (
    patient_id,
    schedule_id,
    diagnostic_centre_id,
    appointment_date,
    time_slot,
    status,
    notes,
    reminder_sent
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, false
) RETURNING id, patient_id, schedule_id, diagnostic_centre_id, appointment_date, time_slot, status, payment_id, payment_status, payment_amount, payment_date, check_in_time, completion_time, notes, cancellation_reason, cancelled_by, cancellation_time, cancellation_fee, original_appointment_id, rescheduling_reason, rescheduled_by, rescheduling_time, rescheduling_fee, created_at, updated_at, reminder_sent, reminder_sent_at
`

type CreateAppointmentParams struct {
	PatientID          string             `db:"patient_id" json:"patient_id"`
	ScheduleID         string             `db:"schedule_id" json:"schedule_id"`
	DiagnosticCentreID string             `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	AppointmentDate    pgtype.Timestamptz `db:"appointment_date" json:"appointment_date"`
	TimeSlot           string             `db:"time_slot" json:"time_slot"`
	Status             AppointmentStatus  `db:"status" json:"status"`
	Notes              pgtype.Text        `db:"notes" json:"notes"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (*Appointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.PatientID,
		arg.ScheduleID,
		arg.DiagnosticCentreID,
		arg.AppointmentDate,
		arg.TimeSlot,
		arg.Status,
		arg.Notes,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.ScheduleID,
		&i.DiagnosticCentreID,
		&i.AppointmentDate,
		&i.TimeSlot,
		&i.Status,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.PaymentAmount,
		&i.PaymentDate,
		&i.CheckInTime,
		&i.CompletionTime,
		&i.Notes,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.CancellationTime,
		&i.CancellationFee,
		&i.OriginalAppointmentID,
		&i.ReschedulingReason,
		&i.RescheduledBy,
		&i.ReschedulingTime,
		&i.ReschedulingFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderSent,
		&i.ReminderSentAt,
	)
	return &i, err
}

const deleteAppointment = `-- name: DeleteAppointment :exec
DELETE FROM appointments WHERE id = $1
`

func (q *Queries) DeleteAppointment(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteAppointment, id)
	return err
}

const getAppointment = `-- name: GetAppointment :one
SELECT id, patient_id, schedule_id, diagnostic_centre_id, appointment_date, time_slot, status, payment_id, payment_status, payment_amount, payment_date, check_in_time, completion_time, notes, cancellation_reason, cancelled_by, cancellation_time, cancellation_fee, original_appointment_id, rescheduling_reason, rescheduled_by, rescheduling_time, rescheduling_fee, created_at, updated_at, reminder_sent, reminder_sent_at FROM appointments WHERE id = $1
`

func (q *Queries) GetAppointment(ctx context.Context, id string) (*Appointment, error) {
	row := q.db.QueryRow(ctx, getAppointment, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.ScheduleID,
		&i.DiagnosticCentreID,
		&i.AppointmentDate,
		&i.TimeSlot,
		&i.Status,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.PaymentAmount,
		&i.PaymentDate,
		&i.CheckInTime,
		&i.CompletionTime,
		&i.Notes,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.CancellationTime,
		&i.CancellationFee,
		&i.OriginalAppointmentID,
		&i.ReschedulingReason,
		&i.RescheduledBy,
		&i.ReschedulingTime,
		&i.ReschedulingFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderSent,
		&i.ReminderSentAt,
	)
	return &i, err
}

const getCentreAppointments = `-- name: GetCentreAppointments :many
SELECT /*+ INDEX(appointments idx_appointments_diagnostic_centre) */ id, patient_id, schedule_id, diagnostic_centre_id, appointment_date, time_slot, status, payment_id, payment_status, payment_amount, payment_date, check_in_time, completion_time, notes, cancellation_reason, cancelled_by, cancellation_time, cancellation_fee, original_appointment_id, rescheduling_reason, rescheduled_by, rescheduling_time, rescheduling_fee, created_at, updated_at, reminder_sent, reminder_sent_at FROM appointments 
WHERE diagnostic_centre_id = $1
AND status = ANY($2::appointment_status[])
AND appointment_date BETWEEN $3 AND $4
ORDER BY appointment_date ASC
LIMIT $5 OFFSET $6
`

type GetCentreAppointmentsParams struct {
	DiagnosticCentreID string              `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	Column2            []AppointmentStatus `db:"column_2" json:"column_2"`
	AppointmentDate    pgtype.Timestamptz  `db:"appointment_date" json:"appointment_date"`
	AppointmentDate_2  pgtype.Timestamptz  `db:"appointment_date_2" json:"appointment_date_2"`
	Limit              int32               `db:"limit" json:"limit"`
	Offset             int32               `db:"offset" json:"offset"`
}

func (q *Queries) GetCentreAppointments(ctx context.Context, arg GetCentreAppointmentsParams) ([]*Appointment, error) {
	rows, err := q.db.Query(ctx, getCentreAppointments,
		arg.DiagnosticCentreID,
		arg.Column2,
		arg.AppointmentDate,
		arg.AppointmentDate_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.ScheduleID,
			&i.DiagnosticCentreID,
			&i.AppointmentDate,
			&i.TimeSlot,
			&i.Status,
			&i.PaymentID,
			&i.PaymentStatus,
			&i.PaymentAmount,
			&i.PaymentDate,
			&i.CheckInTime,
			&i.CompletionTime,
			&i.Notes,
			&i.CancellationReason,
			&i.CancelledBy,
			&i.CancellationTime,
			&i.CancellationFee,
			&i.OriginalAppointmentID,
			&i.ReschedulingReason,
			&i.RescheduledBy,
			&i.ReschedulingTime,
			&i.ReschedulingFee,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderSent,
			&i.ReminderSentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatientAppointments = `-- name: GetPatientAppointments :many
SELECT id, patient_id, schedule_id, diagnostic_centre_id, appointment_date, time_slot, status, payment_id, payment_status, payment_amount, payment_date, check_in_time, completion_time, notes, cancellation_reason, cancelled_by, cancellation_time, cancellation_fee, original_appointment_id, rescheduling_reason, rescheduled_by, rescheduling_time, rescheduling_fee, created_at, updated_at, reminder_sent, reminder_sent_at FROM appointments 
WHERE patient_id = $1
AND status = ANY($2::appointment_status[])
AND appointment_date BETWEEN $3 AND $4
ORDER BY appointment_date ASC
LIMIT $5 OFFSET $6
`

type GetPatientAppointmentsParams struct {
	PatientID         string              `db:"patient_id" json:"patient_id"`
	Column2           []AppointmentStatus `db:"column_2" json:"column_2"`
	AppointmentDate   pgtype.Timestamptz  `db:"appointment_date" json:"appointment_date"`
	AppointmentDate_2 pgtype.Timestamptz  `db:"appointment_date_2" json:"appointment_date_2"`
	Limit             int32               `db:"limit" json:"limit"`
	Offset            int32               `db:"offset" json:"offset"`
}

func (q *Queries) GetPatientAppointments(ctx context.Context, arg GetPatientAppointmentsParams) ([]*Appointment, error) {
	rows, err := q.db.Query(ctx, getPatientAppointments,
		arg.PatientID,
		arg.Column2,
		arg.AppointmentDate,
		arg.AppointmentDate_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.ScheduleID,
			&i.DiagnosticCentreID,
			&i.AppointmentDate,
			&i.TimeSlot,
			&i.Status,
			&i.PaymentID,
			&i.PaymentStatus,
			&i.PaymentAmount,
			&i.PaymentDate,
			&i.CheckInTime,
			&i.CompletionTime,
			&i.Notes,
			&i.CancellationReason,
			&i.CancelledBy,
			&i.CancellationTime,
			&i.CancellationFee,
			&i.OriginalAppointmentID,
			&i.ReschedulingReason,
			&i.RescheduledBy,
			&i.ReschedulingTime,
			&i.ReschedulingFee,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReminderSent,
			&i.ReminderSentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rescheduleAppointment = `-- name: RescheduleAppointment :one
WITH old_appointment AS (
    UPDATE appointments 
    SET 
        status = 'rescheduled',
        rescheduling_reason = $2,
        rescheduled_by = $3,
        rescheduling_time = CURRENT_TIMESTAMP,
        rescheduling_fee = COALESCE($4, 0),
        updated_at = CURRENT_TIMESTAMP
    WHERE appointments.id = $1 
    RETURNING 
        appointments.id as original_appointment_id,
        appointments.patient_id,
        appointments.diagnostic_centre_id,
        appointments.payment_amount,
        appointments.notes
)
INSERT INTO appointments (
    patient_id,
    schedule_id,
    diagnostic_centre_id,
    appointment_date,
    time_slot,
    status,
    payment_amount,
    notes,
    original_appointment_id
) 
SELECT 
    old_appointment.patient_id,
    $5,  -- new_schedule_id
    old_appointment.diagnostic_centre_id,
    $6,  -- new_appointment_date
    $7,  -- new_time_slot
    'confirmed'::appointment_status,
    old_appointment.payment_amount,
    old_appointment.notes,
    old_appointment.original_appointment_id
FROM old_appointment
RETURNING id, patient_id, schedule_id, diagnostic_centre_id, appointment_date, time_slot, status, payment_id, payment_status, payment_amount, payment_date, check_in_time, completion_time, notes, cancellation_reason, cancelled_by, cancellation_time, cancellation_fee, original_appointment_id, rescheduling_reason, rescheduled_by, rescheduling_time, rescheduling_fee, created_at, updated_at, reminder_sent, reminder_sent_at
`

type RescheduleAppointmentParams struct {
	ID                 string             `db:"id" json:"id"`
	ReschedulingReason pgtype.Text        `db:"rescheduling_reason" json:"rescheduling_reason"`
	RescheduledBy      pgtype.UUID        `db:"rescheduled_by" json:"rescheduled_by"`
	ReschedulingFee    pgtype.Numeric     `db:"rescheduling_fee" json:"rescheduling_fee"`
	ScheduleID         string             `db:"schedule_id" json:"schedule_id"`
	AppointmentDate    pgtype.Timestamptz `db:"appointment_date" json:"appointment_date"`
	TimeSlot           string             `db:"time_slot" json:"time_slot"`
}

func (q *Queries) RescheduleAppointment(ctx context.Context, arg RescheduleAppointmentParams) (*Appointment, error) {
	row := q.db.QueryRow(ctx, rescheduleAppointment,
		arg.ID,
		arg.ReschedulingReason,
		arg.RescheduledBy,
		arg.ReschedulingFee,
		arg.ScheduleID,
		arg.AppointmentDate,
		arg.TimeSlot,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.ScheduleID,
		&i.DiagnosticCentreID,
		&i.AppointmentDate,
		&i.TimeSlot,
		&i.Status,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.PaymentAmount,
		&i.PaymentDate,
		&i.CheckInTime,
		&i.CompletionTime,
		&i.Notes,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.CancellationTime,
		&i.CancellationFee,
		&i.OriginalAppointmentID,
		&i.ReschedulingReason,
		&i.RescheduledBy,
		&i.ReschedulingTime,
		&i.ReschedulingFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderSent,
		&i.ReminderSentAt,
	)
	return &i, err
}

const updateAppointmentPayment = `-- name: UpdateAppointmentPayment :one
UPDATE appointments 
SET 
    payment_id = COALESCE($2, payment_id),
    payment_status = COALESCE($3, payment_status),
    payment_amount = COALESCE($4, payment_amount),
    status = COALESCE($5, status),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, patient_id, schedule_id, diagnostic_centre_id, appointment_date, time_slot, status, payment_id, payment_status, payment_amount, payment_date, check_in_time, completion_time, notes, cancellation_reason, cancelled_by, cancellation_time, cancellation_fee, original_appointment_id, rescheduling_reason, rescheduled_by, rescheduling_time, rescheduling_fee, created_at, updated_at, reminder_sent, reminder_sent_at
`

type UpdateAppointmentPaymentParams struct {
	ID            string            `db:"id" json:"id"`
	PaymentID     pgtype.UUID       `db:"payment_id" json:"payment_id"`
	PaymentStatus NullPaymentStatus `db:"payment_status" json:"payment_status"`
	PaymentAmount pgtype.Numeric    `db:"payment_amount" json:"payment_amount"`
	Status        AppointmentStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateAppointmentPayment(ctx context.Context, arg UpdateAppointmentPaymentParams) (*Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointmentPayment,
		arg.ID,
		arg.PaymentID,
		arg.PaymentStatus,
		arg.PaymentAmount,
		arg.Status,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.ScheduleID,
		&i.DiagnosticCentreID,
		&i.AppointmentDate,
		&i.TimeSlot,
		&i.Status,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.PaymentAmount,
		&i.PaymentDate,
		&i.CheckInTime,
		&i.CompletionTime,
		&i.Notes,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.CancellationTime,
		&i.CancellationFee,
		&i.OriginalAppointmentID,
		&i.ReschedulingReason,
		&i.RescheduledBy,
		&i.ReschedulingTime,
		&i.ReschedulingFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderSent,
		&i.ReminderSentAt,
	)
	return &i, err
}

const updateAppointmentStatus = `-- name: UpdateAppointmentStatus :one
UPDATE appointments 
SET 
    status = COALESCE($2, status),
    updated_at = CURRENT_TIMESTAMP,
    check_in_time = CASE 
        WHEN $2 = 'in_progress' AND check_in_time IS NULL THEN CURRENT_TIMESTAMP 
        ELSE check_in_time 
    END,
    completion_time = CASE 
        WHEN $2 = 'completed' AND completion_time IS NULL THEN CURRENT_TIMESTAMP 
        ELSE completion_time 
    END
WHERE id = $1 
RETURNING id, patient_id, schedule_id, diagnostic_centre_id, appointment_date, time_slot, status, payment_id, payment_status, payment_amount, payment_date, check_in_time, completion_time, notes, cancellation_reason, cancelled_by, cancellation_time, cancellation_fee, original_appointment_id, rescheduling_reason, rescheduled_by, rescheduling_time, rescheduling_fee, created_at, updated_at, reminder_sent, reminder_sent_at
`

type UpdateAppointmentStatusParams struct {
	ID     string            `db:"id" json:"id"`
	Status AppointmentStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateAppointmentStatus(ctx context.Context, arg UpdateAppointmentStatusParams) (*Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointmentStatus, arg.ID, arg.Status)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.ScheduleID,
		&i.DiagnosticCentreID,
		&i.AppointmentDate,
		&i.TimeSlot,
		&i.Status,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.PaymentAmount,
		&i.PaymentDate,
		&i.CheckInTime,
		&i.CompletionTime,
		&i.Notes,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.CancellationTime,
		&i.CancellationFee,
		&i.OriginalAppointmentID,
		&i.ReschedulingReason,
		&i.RescheduledBy,
		&i.ReschedulingTime,
		&i.ReschedulingFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderSent,
		&i.ReminderSentAt,
	)
	return &i, err
}

const updateReminderSent = `-- name: UpdateReminderSent :one
UPDATE appointments 
SET reminder_sent = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, patient_id, schedule_id, diagnostic_centre_id, appointment_date, time_slot, status, payment_id, payment_status, payment_amount, payment_date, check_in_time, completion_time, notes, cancellation_reason, cancelled_by, cancellation_time, cancellation_fee, original_appointment_id, rescheduling_reason, rescheduled_by, rescheduling_time, rescheduling_fee, created_at, updated_at, reminder_sent, reminder_sent_at
`

func (q *Queries) UpdateReminderSent(ctx context.Context, id string) (*Appointment, error) {
	row := q.db.QueryRow(ctx, updateReminderSent, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.ScheduleID,
		&i.DiagnosticCentreID,
		&i.AppointmentDate,
		&i.TimeSlot,
		&i.Status,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.PaymentAmount,
		&i.PaymentDate,
		&i.CheckInTime,
		&i.CompletionTime,
		&i.Notes,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.CancellationTime,
		&i.CancellationFee,
		&i.OriginalAppointmentID,
		&i.ReschedulingReason,
		&i.RescheduledBy,
		&i.ReschedulingTime,
		&i.ReschedulingFee,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReminderSent,
		&i.ReminderSentAt,
	)
	return &i, err
}
