// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: availability.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const create_Availability = `-- name: Create_Availability :one
INSERT INTO diagnostic_centre_availability (
    diagnostic_centre_id,
    day_of_week,
    start_time,
    end_time,
    max_appointments,
    slot_duration,
    break_time
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, diagnostic_centre_id, day_of_week, start_time, end_time, max_appointments, slot_duration, break_time, created_at, updated_at
`

type Create_AvailabilityParams struct {
	DiagnosticCentreID string          `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	DayOfWeek          Weekday         `db:"day_of_week" json:"day_of_week"`
	StartTime          pgtype.Time     `db:"start_time" json:"start_time"`
	EndTime            pgtype.Time     `db:"end_time" json:"end_time"`
	MaxAppointments    pgtype.Int4     `db:"max_appointments" json:"max_appointments"`
	SlotDuration       pgtype.Interval `db:"slot_duration" json:"slot_duration"`
	BreakTime          pgtype.Interval `db:"break_time" json:"break_time"`
}

func (q *Queries) Create_Availability(ctx context.Context, arg Create_AvailabilityParams) (*DiagnosticCentreAvailability, error) {
	row := q.db.QueryRow(ctx, create_Availability,
		arg.DiagnosticCentreID,
		arg.DayOfWeek,
		arg.StartTime,
		arg.EndTime,
		arg.MaxAppointments,
		arg.SlotDuration,
		arg.BreakTime,
	)
	var i DiagnosticCentreAvailability
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.MaxAppointments,
		&i.SlotDuration,
		&i.BreakTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const delete_Availability = `-- name: Delete_Availability :exec
DELETE FROM diagnostic_centre_availability
WHERE diagnostic_centre_id = $1
AND day_of_week = $2
`

type Delete_AvailabilityParams struct {
	DiagnosticCentreID string  `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	DayOfWeek          Weekday `db:"day_of_week" json:"day_of_week"`
}

func (q *Queries) Delete_Availability(ctx context.Context, arg Delete_AvailabilityParams) error {
	_, err := q.db.Exec(ctx, delete_Availability, arg.DiagnosticCentreID, arg.DayOfWeek)
	return err
}

const get_Availability = `-- name: Get_Availability :many
SELECT id, diagnostic_centre_id, day_of_week, start_time, end_time, max_appointments, slot_duration, break_time, created_at, updated_at FROM diagnostic_centre_availability
WHERE diagnostic_centre_id = $1
AND ($2::weekday IS NULL OR day_of_week = $2)
ORDER BY
    CASE day_of_week
        WHEN 'monday' THEN 1
        WHEN 'tuesday' THEN 2
        WHEN 'wednesday' THEN 3
        WHEN 'thursday' THEN 4
        WHEN 'friday' THEN 5
        WHEN 'saturday' THEN 6
        WHEN 'sunday' THEN 7
    END
`

type Get_AvailabilityParams struct {
	DiagnosticCentreID string  `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	Column2            Weekday `db:"column_2" json:"column_2"`
}

func (q *Queries) Get_Availability(ctx context.Context, arg Get_AvailabilityParams) ([]*DiagnosticCentreAvailability, error) {
	rows, err := q.db.Query(ctx, get_Availability, arg.DiagnosticCentreID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticCentreAvailability
	for rows.Next() {
		var i DiagnosticCentreAvailability
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.MaxAppointments,
			&i.SlotDuration,
			&i.BreakTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update_Availability = `-- name: Update_Availability :one
UPDATE diagnostic_centre_availability
SET
    start_time = COALESCE($3, start_time),
    end_time = COALESCE($4, end_time),
    max_appointments = COALESCE($5, max_appointments),
    slot_duration = COALESCE($6, slot_duration),
    break_time = COALESCE($7, break_time),
    updated_at = CURRENT_TIMESTAMP
WHERE diagnostic_centre_id = $1
AND day_of_week = $2
RETURNING id, diagnostic_centre_id, day_of_week, start_time, end_time, max_appointments, slot_duration, break_time, created_at, updated_at
`

type Update_AvailabilityParams struct {
	DiagnosticCentreID string          `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	DayOfWeek          Weekday         `db:"day_of_week" json:"day_of_week"`
	StartTime          pgtype.Time     `db:"start_time" json:"start_time"`
	EndTime            pgtype.Time     `db:"end_time" json:"end_time"`
	MaxAppointments    pgtype.Int4     `db:"max_appointments" json:"max_appointments"`
	SlotDuration       pgtype.Interval `db:"slot_duration" json:"slot_duration"`
	BreakTime          pgtype.Interval `db:"break_time" json:"break_time"`
}

func (q *Queries) Update_Availability(ctx context.Context, arg Update_AvailabilityParams) (*DiagnosticCentreAvailability, error) {
	row := q.db.QueryRow(ctx, update_Availability,
		arg.DiagnosticCentreID,
		arg.DayOfWeek,
		arg.StartTime,
		arg.EndTime,
		arg.MaxAppointments,
		arg.SlotDuration,
		arg.BreakTime,
	)
	var i DiagnosticCentreAvailability
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.MaxAppointments,
		&i.SlotDuration,
		&i.BreakTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
