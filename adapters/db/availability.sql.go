// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: availability.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const create_Availability = `-- name: Create_Availability :many
WITH availability_params AS (
    SELECT 
        unnest($1::uuid[]) as diagnostic_centre_id,
        unnest($2::text[]) as day_of_week,
        unnest($3::time[]) as start_time,
        unnest($4::time[]) as end_time,
        unnest($5::int[]) as max_appointments,
        unnest($6::interval[]) as slot_duration,
        unnest($7::interval[]) as break_time
)
INSERT INTO diagnostic_centre_availability (
    diagnostic_centre_id,
    day_of_week,
    start_time,
    end_time,
    max_appointments,
    slot_duration,
    break_time
) 
SELECT diagnostic_centre_id, day_of_week, start_time, end_time, max_appointments, slot_duration, break_time FROM availability_params
RETURNING id, diagnostic_centre_id, day_of_week, start_time, end_time, max_appointments, slot_duration, break_time, created_at, updated_at
`

type Create_AvailabilityParams struct {
	Column1 []string          `db:"column_1" json:"column_1"`
	Column2 []string          `db:"column_2" json:"column_2"`
	Column3 []pgtype.Time     `db:"column_3" json:"column_3"`
	Column4 []pgtype.Time     `db:"column_4" json:"column_4"`
	Column5 []int32           `db:"column_5" json:"column_5"`
	Column6 []pgtype.Interval `db:"column_6" json:"column_6"`
	Column7 []pgtype.Interval `db:"column_7" json:"column_7"`
}

func (q *Queries) Create_Availability(ctx context.Context, arg Create_AvailabilityParams) ([]*DiagnosticCentreAvailability, error) {
	rows, err := q.db.Query(ctx, create_Availability,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticCentreAvailability
	for rows.Next() {
		var i DiagnosticCentreAvailability
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.MaxAppointments,
			&i.SlotDuration,
			&i.BreakTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const create_Single_Availability = `-- name: Create_Single_Availability :one
INSERT INTO diagnostic_centre_availability (
    diagnostic_centre_id,
    day_of_week,
    start_time,
    end_time,
    max_appointments,
    slot_duration,
    break_time
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, diagnostic_centre_id, day_of_week, start_time, end_time, max_appointments, slot_duration, break_time, created_at, updated_at
`

type Create_Single_AvailabilityParams struct {
	DiagnosticCentreID string      `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	DayOfWeek          string      `db:"day_of_week" json:"day_of_week"`
	StartTime          pgtype.Time `db:"start_time" json:"start_time"`
	EndTime            pgtype.Time `db:"end_time" json:"end_time"`
	MaxAppointments    pgtype.Int4 `db:"max_appointments" json:"max_appointments"`
	SlotDuration       int32       `db:"slot_duration" json:"slot_duration"`
	BreakTime          pgtype.Int4 `db:"break_time" json:"break_time"`
}

func (q *Queries) Create_Single_Availability(ctx context.Context, arg Create_Single_AvailabilityParams) (*DiagnosticCentreAvailability, error) {
	row := q.db.QueryRow(ctx, create_Single_Availability,
		arg.DiagnosticCentreID,
		arg.DayOfWeek,
		arg.StartTime,
		arg.EndTime,
		arg.MaxAppointments,
		arg.SlotDuration,
		arg.BreakTime,
	)
	var i DiagnosticCentreAvailability
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.MaxAppointments,
		&i.SlotDuration,
		&i.BreakTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const delete_Availability = `-- name: Delete_Availability :exec
DELETE FROM diagnostic_centre_availability
WHERE diagnostic_centre_id = $1
AND day_of_week = $2
`

type Delete_AvailabilityParams struct {
	DiagnosticCentreID string `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	DayOfWeek          string `db:"day_of_week" json:"day_of_week"`
}

func (q *Queries) Delete_Availability(ctx context.Context, arg Delete_AvailabilityParams) error {
	_, err := q.db.Exec(ctx, delete_Availability, arg.DiagnosticCentreID, arg.DayOfWeek)
	return err
}

const get_Availability = `-- name: Get_Availability :many
SELECT id, diagnostic_centre_id, day_of_week, start_time, end_time, max_appointments, slot_duration, break_time, created_at, updated_at FROM diagnostic_centre_availability
WHERE diagnostic_centre_id = $1
AND ($2::text IS NULL OR day_of_week = $2)
ORDER BY
    CASE day_of_week
        WHEN 'monday' THEN 1
        WHEN 'tuesday' THEN 2
        WHEN 'wednesday' THEN 3
        WHEN 'thursday' THEN 4
        WHEN 'friday' THEN 5
        WHEN 'saturday' THEN 6
        WHEN 'sunday' THEN 7
    END
`

type Get_AvailabilityParams struct {
	DiagnosticCentreID string `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	Column2            string `db:"column_2" json:"column_2"`
}

func (q *Queries) Get_Availability(ctx context.Context, arg Get_AvailabilityParams) ([]*DiagnosticCentreAvailability, error) {
	rows, err := q.db.Query(ctx, get_Availability, arg.DiagnosticCentreID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticCentreAvailability
	for rows.Next() {
		var i DiagnosticCentreAvailability
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.MaxAppointments,
			&i.SlotDuration,
			&i.BreakTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update_Availability = `-- name: Update_Availability :one
UPDATE diagnostic_centre_availability
SET
    start_time = COALESCE($3, start_time),
    end_time = COALESCE($4, end_time),
    max_appointments = COALESCE($5, max_appointments),
    slot_duration = COALESCE($6, slot_duration),
    break_time = COALESCE($7, break_time),
    updated_at = CURRENT_TIMESTAMP
WHERE diagnostic_centre_id = $1
AND day_of_week = $2
RETURNING id, diagnostic_centre_id, day_of_week, start_time, end_time, max_appointments, slot_duration, break_time, created_at, updated_at
`

type Update_AvailabilityParams struct {
	DiagnosticCentreID string      `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	DayOfWeek          string      `db:"day_of_week" json:"day_of_week"`
	StartTime          pgtype.Time `db:"start_time" json:"start_time"`
	EndTime            pgtype.Time `db:"end_time" json:"end_time"`
	MaxAppointments    int32 `db:"max_appointments" json:"max_appointments"`
	SlotDuration       int32       `db:"slot_duration" json:"slot_duration"`
	BreakTime          int32 `db:"break_time" json:"break_time"`
}

func (q *Queries) Update_Availability(ctx context.Context, arg Update_AvailabilityParams) (*DiagnosticCentreAvailability, error) {
	row := q.db.QueryRow(ctx, update_Availability,
		arg.DiagnosticCentreID,
		arg.DayOfWeek,
		arg.StartTime,
		arg.EndTime,
		arg.MaxAppointments,
		arg.SlotDuration,
		arg.BreakTime,
	)
	var i DiagnosticCentreAvailability
	err := row.Scan(
		&i.ID,
		&i.DiagnosticCentreID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.MaxAppointments,
		&i.SlotDuration,
		&i.BreakTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const update_Many_Availability = `-- name: Update_Many_Availability :many
WITH update_params AS (
    SELECT 
        unnest($1::uuid[]) as diagnostic_centre_id,
        unnest($2::weekday[]) as day_of_week,
        unnest($3::time[]) as start_time,
        unnest($4::time[]) as end_time,
        unnest($5::int[]) as max_appointments,
        unnest($6::interval[]) as slot_duration,
        unnest($7::interval[]) as break_time
)
UPDATE diagnostic_centre_availability AS dca
SET
    start_time = COALESCE(up.start_time, dca.start_time),
    end_time = COALESCE(up.end_time, dca.end_time),
    max_appointments = COALESCE(up.max_appointments, dca.max_appointments),
    slot_duration = COALESCE(up.slot_duration, dca.slot_duration),
    break_time = COALESCE(up.break_time, dca.break_time),
    updated_at = CURRENT_TIMESTAMP
FROM update_params up
WHERE dca.diagnostic_centre_id = up.diagnostic_centre_id
AND dca.day_of_week = up.day_of_week
RETURNING dca.id, dca.diagnostic_centre_id, dca.day_of_week, dca.start_time, dca.end_time, dca.max_appointments, dca.slot_duration, dca.break_time, dca.created_at, dca.updated_at
`

type Update_Many_AvailabilityParams struct {
	Column1 []string          `db:"column_1" json:"column_1"`
	Column2 []Weekday         `db:"column_2" json:"column_2"`
	Column3 []pgtype.Time     `db:"column_3" json:"column_3"`
	Column4 []pgtype.Time     `db:"column_4" json:"column_4"`
	Column5 []int32           `db:"column_5" json:"column_5"`
	Column6 []pgtype.Interval `db:"column_6" json:"column_6"`
	Column7 []pgtype.Interval `db:"column_7" json:"column_7"`
}

func (q *Queries) Update_Many_Availability(ctx context.Context, arg Update_Many_AvailabilityParams) ([]*DiagnosticCentreAvailability, error) {
	rows, err := q.db.Query(ctx, update_Many_Availability,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticCentreAvailability
	for rows.Next() {
		var i DiagnosticCentreAvailability
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosticCentreID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.MaxAppointments,
			&i.SlotDuration,
			&i.BreakTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
