// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: payment.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const create_Payment = `-- name: Create_Payment :one
INSERT INTO payments (
    appointment_id,
    patient_id,
    diagnostic_centre_id,
    amount,
    currency,
    payment_method,
    payment_metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, appointment_id, patient_id, diagnostic_centre_id, amount, currency, payment_method, payment_status, transaction_id, payment_metadata, payment_date, refund_amount, refund_reason, refund_date, refunded_by, created_at, updated_at
`

type Create_PaymentParams struct {
	AppointmentID      string         `db:"appointment_id" json:"appointment_id"`
	PatientID          string         `db:"patient_id" json:"patient_id"`
	DiagnosticCentreID string         `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	Amount             pgtype.Numeric `db:"amount" json:"amount"`
	Currency           string         `db:"currency" json:"currency"`
	PaymentMethod      PaymentMethod  `db:"payment_method" json:"payment_method"`
	PaymentMetadata    []byte         `db:"payment_metadata" json:"payment_metadata"`
}

func (q *Queries) Create_Payment(ctx context.Context, arg Create_PaymentParams) (*Payment, error) {
	row := q.db.QueryRow(ctx, create_Payment,
		arg.AppointmentID,
		arg.PatientID,
		arg.DiagnosticCentreID,
		arg.Amount,
		arg.Currency,
		arg.PaymentMethod,
		arg.PaymentMetadata,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.AppointmentID,
		&i.PatientID,
		&i.DiagnosticCentreID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.TransactionID,
		&i.PaymentMetadata,
		&i.PaymentDate,
		&i.RefundAmount,
		&i.RefundReason,
		&i.RefundDate,
		&i.RefundedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const get_Payment = `-- name: Get_Payment :one
SELECT id, appointment_id, patient_id, diagnostic_centre_id, amount, currency, payment_method, payment_status, transaction_id, payment_metadata, payment_date, refund_amount, refund_reason, refund_date, refunded_by, created_at, updated_at FROM payments WHERE id = $1
`

func (q *Queries) Get_Payment(ctx context.Context, id string) (*Payment, error) {
	row := q.db.QueryRow(ctx, get_Payment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.AppointmentID,
		&i.PatientID,
		&i.DiagnosticCentreID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.TransactionID,
		&i.PaymentMetadata,
		&i.PaymentDate,
		&i.RefundAmount,
		&i.RefundReason,
		&i.RefundDate,
		&i.RefundedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const list_Payments = `-- name: List_Payments :many
SELECT id, appointment_id, patient_id, diagnostic_centre_id, amount, currency, payment_method, payment_status, transaction_id, payment_metadata, payment_date, refund_amount, refund_reason, refund_date, refunded_by, created_at, updated_at FROM payments 
WHERE 
    (CASE WHEN $1::UUID IS NOT NULL THEN diagnostic_centre_id = $1 ELSE TRUE END) AND
    (CASE WHEN $2::UUID IS NOT NULL THEN patient_id = $2 ELSE TRUE END) AND
    (CASE WHEN $3::payment_status IS NOT NULL THEN payment_status = $3 ELSE TRUE END) AND
    (CASE WHEN $4::TIMESTAMP IS NOT NULL THEN payment_date >= $4 ELSE TRUE END) AND
    (CASE WHEN $5::TIMESTAMP IS NOT NULL THEN payment_date <= $5 ELSE TRUE END)
ORDER BY created_at DESC
LIMIT $6 OFFSET $7
`

type List_PaymentsParams struct {
	Column1 string           `db:"column_1" json:"column_1"`
	Column2 string           `db:"column_2" json:"column_2"`
	Column3 PaymentStatus    `db:"column_3" json:"column_3"`
	Column4 pgtype.Timestamp `db:"column_4" json:"column_4"`
	Column5 pgtype.Timestamp `db:"column_5" json:"column_5"`
	Limit   int32            `db:"limit" json:"limit"`
	Offset  int32            `db:"offset" json:"offset"`
}

func (q *Queries) List_Payments(ctx context.Context, arg List_PaymentsParams) ([]*Payment, error) {
	rows, err := q.db.Query(ctx, list_Payments,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.AppointmentID,
			&i.PatientID,
			&i.DiagnosticCentreID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.TransactionID,
			&i.PaymentMetadata,
			&i.PaymentDate,
			&i.RefundAmount,
			&i.RefundReason,
			&i.RefundDate,
			&i.RefundedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refund_Payment = `-- name: Refund_Payment :one
UPDATE payments 
SET 
    payment_status = 'refunded',
    refund_amount = $2,
    refund_reason = $3,
    refund_date = CURRENT_TIMESTAMP,
    refunded_by = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE 
    payments.id = $1 AND 
    payment_status = 'success' AND
    NOT EXISTS (
        SELECT 1 FROM payments AS p
        WHERE p.id = payments.id AND p.refund_amount IS NOT NULL
    )
RETURNING id, appointment_id, patient_id, diagnostic_centre_id, amount, currency, payment_method, payment_status, transaction_id, payment_metadata, payment_date, refund_amount, refund_reason, refund_date, refunded_by, created_at, updated_at
`

type Refund_PaymentParams struct {
	ID           string         `db:"id" json:"id"`
	RefundAmount pgtype.Numeric `db:"refund_amount" json:"refund_amount"`
	RefundReason pgtype.Text    `db:"refund_reason" json:"refund_reason"`
	RefundedBy   pgtype.UUID    `db:"refunded_by" json:"refunded_by"`
}

func (q *Queries) Refund_Payment(ctx context.Context, arg Refund_PaymentParams) (*Payment, error) {
	row := q.db.QueryRow(ctx, refund_Payment,
		arg.ID,
		arg.RefundAmount,
		arg.RefundReason,
		arg.RefundedBy,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.AppointmentID,
		&i.PatientID,
		&i.DiagnosticCentreID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.TransactionID,
		&i.PaymentMetadata,
		&i.PaymentDate,
		&i.RefundAmount,
		&i.RefundReason,
		&i.RefundDate,
		&i.RefundedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const update_Payment_Status = `-- name: Update_Payment_Status :one
UPDATE payments 
SET 
    payment_status = $2,
    payment_date = CASE 
        WHEN $2 = 'success' THEN CURRENT_TIMESTAMP 
        ELSE payment_date 
    END,
    transaction_id = $3,
    payment_metadata = COALESCE($4, payment_metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 
RETURNING id, appointment_id, patient_id, diagnostic_centre_id, amount, currency, payment_method, payment_status, transaction_id, payment_metadata, payment_date, refund_amount, refund_reason, refund_date, refunded_by, created_at, updated_at
`

type Update_Payment_StatusParams struct {
	ID              string        `db:"id" json:"id"`
	PaymentStatus   PaymentStatus `db:"payment_status" json:"payment_status"`
	TransactionID   pgtype.Text   `db:"transaction_id" json:"transaction_id"`
	PaymentMetadata []byte        `db:"payment_metadata" json:"payment_metadata"`
}

func (q *Queries) Update_Payment_Status(ctx context.Context, arg Update_Payment_StatusParams) (*Payment, error) {
	row := q.db.QueryRow(ctx, update_Payment_Status,
		arg.ID,
		arg.PaymentStatus,
		arg.TransactionID,
		arg.PaymentMetadata,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.AppointmentID,
		&i.PatientID,
		&i.DiagnosticCentreID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.TransactionID,
		&i.PaymentMetadata,
		&i.PaymentDate,
		&i.RefundAmount,
		&i.RefundReason,
		&i.RefundDate,
		&i.RefundedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
