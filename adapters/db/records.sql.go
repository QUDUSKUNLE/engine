// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: records.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMedicalRecord = `-- name: CreateMedicalRecord :one
INSERT INTO medical_records (
  user_id,
  uploader_id,
  uploader_admin_id,
  uploader_type,
  schedule_id,
  title,
  document_type,
  document_date,
  file_path,
  file_type,
  uploaded_at,
  provider_name,
  specialty,
  is_shared,
  shared_until
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, user_id, uploader_id, uploader_type, schedule_id, title, document_type, file_path, file_type, document_date, uploaded_at, provider_name, specialty, is_shared, shared_until, created_at, updated_at, uploader_admin_id
`

type CreateMedicalRecordParams struct {
	UserID          string           `db:"user_id" json:"user_id"`
	UploaderID      string           `db:"uploader_id" json:"uploader_id"`
	UploaderAdminID pgtype.UUID      `db:"uploader_admin_id" json:"uploader_admin_id"`
	UploaderType    UserEnum         `db:"uploader_type" json:"uploader_type"`
	ScheduleID      string           `db:"schedule_id" json:"schedule_id"`
	Title           string           `db:"title" json:"title"`
	DocumentType    DocumentType     `db:"document_type" json:"document_type"`
	DocumentDate    pgtype.Date      `db:"document_date" json:"document_date"`
	FilePath        string           `db:"file_path" json:"file_path"`
	FileType        pgtype.Text      `db:"file_type" json:"file_type"`
	UploadedAt      pgtype.Timestamp `db:"uploaded_at" json:"uploaded_at"`
	ProviderName    pgtype.Text      `db:"provider_name" json:"provider_name"`
	Specialty       pgtype.Text      `db:"specialty" json:"specialty"`
	IsShared        pgtype.Bool      `db:"is_shared" json:"is_shared"`
	SharedUntil     pgtype.Timestamp `db:"shared_until" json:"shared_until"`
}

// Create a Medical Record
func (q *Queries) CreateMedicalRecord(ctx context.Context, arg CreateMedicalRecordParams) (*MedicalRecord, error) {
	row := q.db.QueryRow(ctx, createMedicalRecord,
		arg.UserID,
		arg.UploaderID,
		arg.UploaderAdminID,
		arg.UploaderType,
		arg.ScheduleID,
		arg.Title,
		arg.DocumentType,
		arg.DocumentDate,
		arg.FilePath,
		arg.FileType,
		arg.UploadedAt,
		arg.ProviderName,
		arg.Specialty,
		arg.IsShared,
		arg.SharedUntil,
	)
	var i MedicalRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UploaderID,
		&i.UploaderType,
		&i.ScheduleID,
		&i.Title,
		&i.DocumentType,
		&i.FilePath,
		&i.FileType,
		&i.DocumentDate,
		&i.UploadedAt,
		&i.ProviderName,
		&i.Specialty,
		&i.IsShared,
		&i.SharedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UploaderAdminID,
	)
	return &i, err
}

const getMedicalRecord = `-- name: GetMedicalRecord :one
SELECT id, user_id, uploader_id, uploader_admin_id, uploader_type, schedule_id, title, document_type, document_date, file_path, file_type, uploaded_at, provider_name, specialty, is_shared, shared_until, created_at, updated_at
FROM medical_records WHERE id = $1 AND user_id = $2
`

type GetMedicalRecordParams struct {
	ID     string `db:"id" json:"id"`
	UserID string `db:"user_id" json:"user_id"`
}

type GetMedicalRecordRow struct {
	ID              string             `db:"id" json:"id"`
	UserID          string             `db:"user_id" json:"user_id"`
	UploaderID      string             `db:"uploader_id" json:"uploader_id"`
	UploaderAdminID pgtype.UUID        `db:"uploader_admin_id" json:"uploader_admin_id"`
	UploaderType    UserEnum           `db:"uploader_type" json:"uploader_type"`
	ScheduleID      string             `db:"schedule_id" json:"schedule_id"`
	Title           string             `db:"title" json:"title"`
	DocumentType    DocumentType       `db:"document_type" json:"document_type"`
	DocumentDate    pgtype.Date        `db:"document_date" json:"document_date"`
	FilePath        string             `db:"file_path" json:"file_path"`
	FileType        pgtype.Text        `db:"file_type" json:"file_type"`
	UploadedAt      pgtype.Timestamp   `db:"uploaded_at" json:"uploaded_at"`
	ProviderName    pgtype.Text        `db:"provider_name" json:"provider_name"`
	Specialty       pgtype.Text        `db:"specialty" json:"specialty"`
	IsShared        pgtype.Bool        `db:"is_shared" json:"is_shared"`
	SharedUntil     pgtype.Timestamp   `db:"shared_until" json:"shared_until"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Get a Medical Record
func (q *Queries) GetMedicalRecord(ctx context.Context, arg GetMedicalRecordParams) (*GetMedicalRecordRow, error) {
	row := q.db.QueryRow(ctx, getMedicalRecord, arg.ID, arg.UserID)
	var i GetMedicalRecordRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UploaderID,
		&i.UploaderAdminID,
		&i.UploaderType,
		&i.ScheduleID,
		&i.Title,
		&i.DocumentType,
		&i.DocumentDate,
		&i.FilePath,
		&i.FileType,
		&i.UploadedAt,
		&i.ProviderName,
		&i.Specialty,
		&i.IsShared,
		&i.SharedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMedicalRecords = `-- name: GetMedicalRecords :many
SELECT id, user_id, uploader_id, uploader_admin_id, uploader_type, schedule_id, title, document_type, document_date, file_path, file_type, uploaded_at, provider_name, specialty, is_shared, shared_until, created_at FROM medical_records
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetMedicalRecordsParams struct {
	UserID string `db:"user_id" json:"user_id"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

type GetMedicalRecordsRow struct {
	ID              string             `db:"id" json:"id"`
	UserID          string             `db:"user_id" json:"user_id"`
	UploaderID      string             `db:"uploader_id" json:"uploader_id"`
	UploaderAdminID pgtype.UUID        `db:"uploader_admin_id" json:"uploader_admin_id"`
	UploaderType    UserEnum           `db:"uploader_type" json:"uploader_type"`
	ScheduleID      string             `db:"schedule_id" json:"schedule_id"`
	Title           string             `db:"title" json:"title"`
	DocumentType    DocumentType       `db:"document_type" json:"document_type"`
	DocumentDate    pgtype.Date        `db:"document_date" json:"document_date"`
	FilePath        string             `db:"file_path" json:"file_path"`
	FileType        pgtype.Text        `db:"file_type" json:"file_type"`
	UploadedAt      pgtype.Timestamp   `db:"uploaded_at" json:"uploaded_at"`
	ProviderName    pgtype.Text        `db:"provider_name" json:"provider_name"`
	Specialty       pgtype.Text        `db:"specialty" json:"specialty"`
	IsShared        pgtype.Bool        `db:"is_shared" json:"is_shared"`
	SharedUntil     pgtype.Timestamp   `db:"shared_until" json:"shared_until"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

// Get Medical Records
// Retrieves a paginated list of medical records for a specific user, ordered by creation date (most recent first).
func (q *Queries) GetMedicalRecords(ctx context.Context, arg GetMedicalRecordsParams) ([]*GetMedicalRecordsRow, error) {
	rows, err := q.db.Query(ctx, getMedicalRecords, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMedicalRecordsRow
	for rows.Next() {
		var i GetMedicalRecordsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UploaderID,
			&i.UploaderAdminID,
			&i.UploaderType,
			&i.ScheduleID,
			&i.Title,
			&i.DocumentType,
			&i.DocumentDate,
			&i.FilePath,
			&i.FileType,
			&i.UploadedAt,
			&i.ProviderName,
			&i.Specialty,
			&i.IsShared,
			&i.SharedUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUploaderMedicalRecord = `-- name: GetUploaderMedicalRecord :one
SELECT id, user_id, uploader_id, uploader_admin_id, uploader_type, schedule_id, title, document_type, document_date, file_path, file_type, uploaded_at, provider_name, specialty, is_shared, shared_until, created_at, updated_at
FROM medical_records WHERE id = $1 AND uploader_id = $2 AND uploader_admin_id = $3
`

type GetUploaderMedicalRecordParams struct {
	ID              string      `db:"id" json:"id"`
	UploaderID      string      `db:"uploader_id" json:"uploader_id"`
	UploaderAdminID pgtype.UUID `db:"uploader_admin_id" json:"uploader_admin_id"`
}

type GetUploaderMedicalRecordRow struct {
	ID              string             `db:"id" json:"id"`
	UserID          string             `db:"user_id" json:"user_id"`
	UploaderID      string             `db:"uploader_id" json:"uploader_id"`
	UploaderAdminID pgtype.UUID        `db:"uploader_admin_id" json:"uploader_admin_id"`
	UploaderType    UserEnum           `db:"uploader_type" json:"uploader_type"`
	ScheduleID      string             `db:"schedule_id" json:"schedule_id"`
	Title           string             `db:"title" json:"title"`
	DocumentType    DocumentType       `db:"document_type" json:"document_type"`
	DocumentDate    pgtype.Date        `db:"document_date" json:"document_date"`
	FilePath        string             `db:"file_path" json:"file_path"`
	FileType        pgtype.Text        `db:"file_type" json:"file_type"`
	UploadedAt      pgtype.Timestamp   `db:"uploaded_at" json:"uploaded_at"`
	ProviderName    pgtype.Text        `db:"provider_name" json:"provider_name"`
	Specialty       pgtype.Text        `db:"specialty" json:"specialty"`
	IsShared        pgtype.Bool        `db:"is_shared" json:"is_shared"`
	SharedUntil     pgtype.Timestamp   `db:"shared_until" json:"shared_until"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// Get an Uploader Medical Record
// Retrieves a medical record by its ID and uploader ID.
func (q *Queries) GetUploaderMedicalRecord(ctx context.Context, arg GetUploaderMedicalRecordParams) (*GetUploaderMedicalRecordRow, error) {
	row := q.db.QueryRow(ctx, getUploaderMedicalRecord, arg.ID, arg.UploaderID, arg.UploaderAdminID)
	var i GetUploaderMedicalRecordRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UploaderID,
		&i.UploaderAdminID,
		&i.UploaderType,
		&i.ScheduleID,
		&i.Title,
		&i.DocumentType,
		&i.DocumentDate,
		&i.FilePath,
		&i.FileType,
		&i.UploadedAt,
		&i.ProviderName,
		&i.Specialty,
		&i.IsShared,
		&i.SharedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getUploaderMedicalRecords = `-- name: GetUploaderMedicalRecords :many
SELECT id, user_id, uploader_id, uploader_admin_id, uploader_type, schedule_id, title, document_type, document_date, file_path, file_type, uploaded_at, provider_name, specialty, is_shared, shared_until, created_at FROM medical_records
WHERE uploader_id = $1 AND uploader_admin_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetUploaderMedicalRecordsParams struct {
	UploaderID      string      `db:"uploader_id" json:"uploader_id"`
	UploaderAdminID pgtype.UUID `db:"uploader_admin_id" json:"uploader_admin_id"`
	Limit           int32       `db:"limit" json:"limit"`
	Offset          int32       `db:"offset" json:"offset"`
}

type GetUploaderMedicalRecordsRow struct {
	ID              string             `db:"id" json:"id"`
	UserID          string             `db:"user_id" json:"user_id"`
	UploaderID      string             `db:"uploader_id" json:"uploader_id"`
	UploaderAdminID pgtype.UUID        `db:"uploader_admin_id" json:"uploader_admin_id"`
	UploaderType    UserEnum           `db:"uploader_type" json:"uploader_type"`
	ScheduleID      string             `db:"schedule_id" json:"schedule_id"`
	Title           string             `db:"title" json:"title"`
	DocumentType    DocumentType       `db:"document_type" json:"document_type"`
	DocumentDate    pgtype.Date        `db:"document_date" json:"document_date"`
	FilePath        string             `db:"file_path" json:"file_path"`
	FileType        pgtype.Text        `db:"file_type" json:"file_type"`
	UploadedAt      pgtype.Timestamp   `db:"uploaded_at" json:"uploaded_at"`
	ProviderName    pgtype.Text        `db:"provider_name" json:"provider_name"`
	Specialty       pgtype.Text        `db:"specialty" json:"specialty"`
	IsShared        pgtype.Bool        `db:"is_shared" json:"is_shared"`
	SharedUntil     pgtype.Timestamp   `db:"shared_until" json:"shared_until"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

// Get Uploader Medical Records
// Retrieves a paginated list of medical records uploaded by a specific uploader, explicitly ordered by creation date in descending order (most recent first).
func (q *Queries) GetUploaderMedicalRecords(ctx context.Context, arg GetUploaderMedicalRecordsParams) ([]*GetUploaderMedicalRecordsRow, error) {
	rows, err := q.db.Query(ctx, getUploaderMedicalRecords,
		arg.UploaderID,
		arg.UploaderAdminID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUploaderMedicalRecordsRow
	for rows.Next() {
		var i GetUploaderMedicalRecordsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UploaderID,
			&i.UploaderAdminID,
			&i.UploaderType,
			&i.ScheduleID,
			&i.Title,
			&i.DocumentType,
			&i.DocumentDate,
			&i.FilePath,
			&i.FileType,
			&i.UploadedAt,
			&i.ProviderName,
			&i.Specialty,
			&i.IsShared,
			&i.SharedUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFilePath = `-- name: UpdateFilePath :one
UPDATE medical_records
SET
  file_path = COALESCE($2, file_path),
  updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, uploader_id, uploader_type, schedule_id, title, document_type, file_path, file_type, document_date, uploaded_at, provider_name, specialty, is_shared, shared_until, created_at, updated_at, uploader_admin_id
`

type UpdateFilePathParams struct {
	ID       string `db:"id" json:"id"`
	FilePath string `db:"file_path" json:"file_path"`
}

func (q *Queries) UpdateFilePath(ctx context.Context, arg UpdateFilePathParams) (*MedicalRecord, error) {
	row := q.db.QueryRow(ctx, updateFilePath, arg.ID, arg.FilePath)
	var i MedicalRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UploaderID,
		&i.UploaderType,
		&i.ScheduleID,
		&i.Title,
		&i.DocumentType,
		&i.FilePath,
		&i.FileType,
		&i.DocumentDate,
		&i.UploadedAt,
		&i.ProviderName,
		&i.Specialty,
		&i.IsShared,
		&i.SharedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UploaderAdminID,
	)
	return &i, err
}

const updateMedicalRecordByUploader = `-- name: UpdateMedicalRecordByUploader :one
UPDATE medical_records
SET 
  title = COALESCE($1, title),
  document_type = COALESCE($2, document_type),
  document_date = COALESCE($3, document_date),
  file_path = COALESCE($4, file_path),
  file_type = COALESCE($5, file_type),
  uploaded_at = COALESCE($6, uploaded_at),
  provider_name = COALESCE($7, provider_name),
  specialty = COALESCE($8, specialty),
  is_shared = COALESCE($9, is_shared),
  shared_until = COALESCE($10, shared_until),
  updated_at = NOW()
WHERE id = $11 AND uploader_id = $12 AND uploader_admin_id = $13
RETURNING id, user_id, uploader_id, uploader_type, schedule_id, title, document_type, file_path, file_type, document_date, uploaded_at, provider_name, specialty, is_shared, shared_until, created_at, updated_at, uploader_admin_id
`

type UpdateMedicalRecordByUploaderParams struct {
	Title           string           `db:"title" json:"title"`
	DocumentType    DocumentType     `db:"document_type" json:"document_type"`
	DocumentDate    pgtype.Date      `db:"document_date" json:"document_date"`
	FilePath        string           `db:"file_path" json:"file_path"`
	FileType        pgtype.Text      `db:"file_type" json:"file_type"`
	UploadedAt      pgtype.Timestamp `db:"uploaded_at" json:"uploaded_at"`
	ProviderName    pgtype.Text      `db:"provider_name" json:"provider_name"`
	Specialty       pgtype.Text      `db:"specialty" json:"specialty"`
	IsShared        pgtype.Bool      `db:"is_shared" json:"is_shared"`
	SharedUntil     pgtype.Timestamp `db:"shared_until" json:"shared_until"`
	ID              string           `db:"id" json:"id"`
	UploaderID      string           `db:"uploader_id" json:"uploader_id"`
	UploaderAdminID pgtype.UUID      `db:"uploader_admin_id" json:"uploader_admin_id"`
}

// Uploader Update a Medical Record
// Updates a medical record by uploader, allowing partial updates to fields. Only the uploader can update their own records. Updates the 'updated_at' timestamp.
func (q *Queries) UpdateMedicalRecordByUploader(ctx context.Context, arg UpdateMedicalRecordByUploaderParams) (*MedicalRecord, error) {
	row := q.db.QueryRow(ctx, updateMedicalRecordByUploader,
		arg.Title,
		arg.DocumentType,
		arg.DocumentDate,
		arg.FilePath,
		arg.FileType,
		arg.UploadedAt,
		arg.ProviderName,
		arg.Specialty,
		arg.IsShared,
		arg.SharedUntil,
		arg.ID,
		arg.UploaderID,
		arg.UploaderAdminID,
	)
	var i MedicalRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UploaderID,
		&i.UploaderType,
		&i.ScheduleID,
		&i.Title,
		&i.DocumentType,
		&i.FilePath,
		&i.FileType,
		&i.DocumentDate,
		&i.UploadedAt,
		&i.ProviderName,
		&i.Specialty,
		&i.IsShared,
		&i.SharedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UploaderAdminID,
	)
	return &i, err
}
